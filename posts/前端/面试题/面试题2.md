---
title: 面试题2
date: 2024-10-12 22:38:04
description: 笔记
tags:
 - 前端面试题
---

## 1. JS原始类型有哪些？

- **Number**：表示数值（整数和浮点数）。
- **String**：表示文本字符串。
- **Boolean**：表示布尔值（true 或 false）。
- **Null**：表示空值，指明一个空对象引用。
- **Undefined**：表示未定义的值，变量声明但未赋值时默认值为 `undefined`。
- **Symbol**：表示唯一的不可变值，通常用作对象属性的标识符。
- **BigInt**：用于表示任意精度的整数。

## 2. 它们存在栈中还是堆里的呢？

原始类型的值是**不可变的**，并且由于它们大小固定、内存分配相对简单，通常存储在**栈**中。这使得它们的访问速度非常快。而引用类型（如对象、数组、函数）存储在堆中。

## 3. 引用类型有哪些？

引用类型包括：

- **Object**：这是 JavaScript 中最基本的引用类型，包括普通对象（如 `{}`）、数组（如 `[]`）、函数（如 `function () {}`）等。
- **Array**：一种特殊类型的对象，用于存储有序的集合。
- **Function**：也是一种特殊的对象，可以被调用。
- **Date**：用于表示日期和时间。
- **RegExp**：用于表示正则表达式。
- **Map**、**Set**：ES6 引入的集合类型。
- **WeakMap**、**WeakSet**：类似于 `Map` 和 `Set`，但对键或元素是弱引用。

## 4. 他们为什么要去区分呢？都存在栈里面有没有问题？

区分原始类型和引用类型的主要原因是**内存管理和性能**。

- **原始类型**的数据大小固定，通常很小，因此存储在栈中，这样可以提高访问速度。
- **引用类型**通常是复杂的数据结构，大小不固定，因此存储在堆中，栈中只存储它们的引用（即指针）。如果引用类型也存在栈中，可能会导致栈溢出，影响性能和稳定性。

## 5. 调用栈的数据是怎么回收的？堆的数据是怎么回收的？

- **调用栈中的数据**：栈是通过**自动管理**的。当函数执行完毕后，函数调用所占用的内存会自动释放。因此，栈中的数据回收不需要手动干预，由系统自动管理。
- **堆中的数据**：堆内存由垃圾回收机制（如 JavaScript 引擎的垃圾回收器）管理，主要采用**标记-清除**、**引用计数**等算法。当一个对象不再被引用时，它占用的内存将被标记为可回收，垃圾回收器会在合适的时间回收这些内存。

## 6. ES Module 和 CommonJS区别

[commonJS 和 ES Module 区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161015809)

- **ES Module**：
  - 语法：`import` 和 `export`。 异步
  - 模块是静态加载的，即在**编译时**解析依赖关系，确定模块导入导出。
  - 是原生支持的模块系统，浏览器和 Node.js 12+ 版本都支持。
  - 支持**树摇**（Tree Shaking）优化未使用的代码。
  - e导出是引用值之前都存在映射关系，并且值都是可读的，不能修改
- **CommonJS**：
  - 语法：`require` 和 `module.exports`。同步加载模块
  - 模块是动态加载的，依赖关系在**运行时**解析。
  - 主要用于 Node.js 环境中，浏览器中需借助工具（如 Browserify、Webpack）转换。
  - 不支持树摇优化，因为模块加载是动态的。
  - 导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染

## 7. 浏览器事件循环机制

[浏览器事件循环看这一篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/7024751918484291591)

浏览器的事件循环机制用于管理异步操作的执行顺序。主线程执行同步代码，异步任务（如 `setTimeout`、`Promise`）推送到任务队列，主线程空闲时从任务队列中取出任务执行。事件循环（Event Loop）不断检查调用栈和任务队列的状态，确保异步代码能在正确的时间点被执行。

## 8. 宏任务和微任务是什么？哪些属于宏任务哪些属于微任务？

- **宏任务**：包括 script（整体代码）、`setTimeout`、`setInterval`、`I/O` 操作等。宏任务执行完后，事件循环会查看微任务队列并执行所有微任务，然后再执行下一个宏任务。
- **微任务**：包括 `Promise.then`、`MutationObserver`（监听和响应 DOM 的变化）、`queueMicrotask`。微任务在当前宏任务结束后、下一个宏任务开始前执行。

## 9. HTTP1和HTTP2的区别

- **HTTP1**：
  - 每个请求都需要单独的 TCP 连接，导致性能瓶颈。
  - 头部冗余，每次请求都会重复发送相同的头部信息。
- **HTTP2**：
  - 支持**多路复用**，一个连接上可以发送多个请求，极大地减少了延迟。
  - 头部压缩，减少数据传输量。
  - 服务端推送，服务器可以主动将资源推送到客户端。

## 10. 多路复用是什么？主要解决什么问题？

多路复用允许在一个 TCP 连接上同时发送多个 HTTP 请求，解决了 HTTP/1.1 中“每个请求需要一个连接”的问题，减少了连接的建立和管理开销，提高了传输效率。